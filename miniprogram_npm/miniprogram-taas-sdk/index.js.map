{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const sm2 = require('sm-crypto').sm2;\r\n\r\nconst addresses = ['https://node0.taas.internetapi.cn'];\r\n\r\n// ServerAddr GetServerAddr()\r\n/**\r\n * Get TaaS backend server address.\r\n *\r\n * @return an address of a TaaS backend server. If there are multiple available servers, return a random one.\r\n */\r\nfunction getServerAddr() {\r\n    if (addresses.length === 1) {\r\n        return addresses[0];\r\n    }\r\n    return addresses[Math.floor(Math.random() * addresses.length)];\r\n};\r\n\r\n// AccessToken register(InvitationCode, ServerAddr, Cred)\r\n/**\r\n * Register with invitation code and public key, get the access token.\r\n *\r\n * @param invitationCode    the invitation code\r\n * @param serverAddr        the server address\r\n * @param credential        an object that is returned by sdk.getCredential()\r\n * @param callback          a function called when the server has responded the sdk.register request.\r\n * @return null.\r\n */\r\nfunction register(invitationCode, serverAddr, credential, callback){\r\n    var url = serverAddr;\r\n    if (!url) url = getServerAddr();\r\n    url = url + \"/auth/register\";\r\n\r\n    var formData = {\r\n        from: credential.publicKey,\r\n        verifyCode: invitationCode\r\n    };\r\n\r\n    var params = {\r\n        url: url,\r\n        method: \"POST\",\r\n        timeout: 0,\r\n        header: {\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        },\r\n        data: formData\r\n    };\r\n    params.success = (res) => {\r\n        if (res.data.code !== 0){\r\n            callback(new Error(res.data.message));\r\n            return ;\r\n        }\r\n\r\n        var token = res.data.data.accessToken;\r\n        callback(undefined, token);\r\n    };\r\n    params.fail = (res) => {callback(new Error(\"network error\"));};\r\n    wx.request(params);\r\n};\r\n\r\n// Cred GetCredential()\r\n/**\r\n * Generate a public key, private key and credential, i.e. access token\r\n *\r\n * @return null.\r\n */\r\nfunction getCredential(invitationCode, serverAddr, callback) {\r\n    let cred = sm2.generateKeyPairHex();\r\n\r\n    register(invitationCode, serverAddr, cred, (err, data) => {\r\n        if (err) {\r\n            callback(err);\r\n            return ;\r\n        };\r\n\r\n        var r = {\r\n            publicKey: cred.publicKey,\r\n            privateKey: cred.privateKey,\r\n            credential: data\r\n        };\r\n        callback(undefined, r);\r\n    });\r\n};\r\n\r\n/**\r\n * Get the signature of given message by a private key.\r\n *\r\n * @param text the message to make signature\r\n * @param credential a public key and private key pair\r\n * @return the signature of given message.\r\n */\r\nfunction signature(text, credential) {\r\n    return sm2.doSignature(text, credential.privateKey);\r\n};\r\n\r\n// HashID StoreEvidence(Data, ServerAddr, Cred)\r\n/**\r\n * Store evidence of the data in the TaaS backend.\r\n *\r\n * @param data          the message to be stored\r\n * @param serverAddr    the server address\r\n * @param credential    an object that is returned by sdk.getCredential()\r\n * @param callback      a function called when the server has responded the sdk.storeEvidence request.\r\n * @return null.\r\n */\r\nfunction storeEvidence(data, serverAddr, credential, callback){\r\n    var text, path;\r\n    if (typeof data === \"object\"){\r\n        text = data.text;\r\n        path = data.path;\r\n    } else if (typeof data === \"string\"){\r\n        text = data;\r\n    } else {\r\n        throw new Error(`unidentified type of data: ${typeof data}`);\r\n    };\r\n\r\n    if (!path && !text)\r\n        throw new Error(\"no data to store\");\r\n    if (!credential)\r\n        throw new Error(\"no credential\");\r\n    if (!callback)\r\n        throw new Error(\"no callback\");\r\n\r\n    var sig;\r\n    if (text){\r\n        sig = signature(text, credential);\r\n    } else {\r\n        sig = signature(path, credential);\r\n    }\r\n\r\n    var url = serverAddr;\r\n    if (!url) url = getServerAddr();\r\n\r\n    if (!path){\r\n        url = url + \"/uploadMessage\";\r\n        var formData = {\r\n            from: credential.publicKey,\r\n            data: text,\r\n            sig: sig,\r\n            accessToken: credential.credential\r\n        };\r\n\r\n        var params = {\r\n            url: url,\r\n            method: \"POST\",\r\n            timeout: 0,\r\n            header: {\r\n                \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n            },\r\n            data: formData\r\n        };\r\n\r\n        params.success = (res) => {\r\n            if (res.data.code !== 0){\r\n                callback(new Error(res.data.message));\r\n                return ;\r\n            }\r\n            callback(undefined, res.data.data);\r\n        };\r\n        params.fail = () => {callback(new Error(\"network error\"));};\r\n        wx.request(params);\r\n    } else {\r\n        url = url + \"/uploadFile\";\r\n        var formData = {\r\n            from: credential.publicKey,\r\n            sig: sig,\r\n            accessToken: credential.credential\r\n        };\r\n        if (text) formData.text = text;\r\n\r\n        var params = {\r\n            url: url,\r\n            method: 'POST',\r\n            name: \"data\",\r\n            filePath: path,\r\n            formData: formData\r\n        };\r\n        params.success = (res) => {\r\n            var data = JSON.parse(res.data);\r\n            if (data.code !== 0){\r\n                callback(new Error(data.message));\r\n                return ;\r\n            }\r\n            callback(undefined, data.data);\r\n        };\r\n        params.fail = () => {callback(new Error(\"network error\"));};\r\n        wx.uploadFile(params);\r\n    };\r\n};\r\n\r\n// Data QueryEvidence(HashID, ServerAddr, Cred)\r\n/**\r\n * Query the data according to a hash ID.\r\n *\r\n * @param hashID        the hash value to be queried\r\n * @param serverAddr    the server address\r\n * @param credential    an object that is returned by sdk.getCredential()\r\n * @param callback      a function called when the server has responded the sdk.queryEvidence request.\r\n * @return null.\r\n */\r\n function queryEvidence(hashId, serverAddr, credential, callback){\r\n    if (!callback)\r\n        throw new Error(\"no callback\");\r\n\r\n    var url = serverAddr;\r\n    if (!url) url = getServerAddr();\r\n    url = url + \"/queryData\";\r\n\r\n    var params = {\r\n        url: url,\r\n        method: \"POST\",\r\n        timeout: 0,\r\n        header: {\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        },\r\n        data: {\r\n            hash: hashId,\r\n            from: credential.publicKey,\r\n            accessToken: credential.credential\r\n        }\r\n    };\r\n\r\n    params.success = (res) => {\r\n        if (res.data.code !== 0){\r\n            callback(new Error(res.data.message));\r\n            return ;\r\n        }\r\n        var data = res.data.data;\r\n        var d = data.data;\r\n        if (!d.type || d.type === \"text\"){\r\n            d.text = d.data;\r\n            delete d.data;\r\n        };\r\n        callback(undefined, data);\r\n    };\r\n    params.fail = () => {\r\n        callback(new Error(\"network error\"));\r\n    };\r\n    wx.request(params);\r\n};\r\n\r\n/**\r\n * List current smart contract list of given user access token and server address.\r\n *\r\n * @param serverAddr    the server address\r\n * @param credential    an object that is returned by sdk.getCredential()\r\n * @param callback      a function called when the server has responded the sdk.getContractList request.\r\n * @return null.\r\n */\r\nfunction getContractList(serverAddr, credential, callback) {\r\n    if (!serverAddr) serverAddr = getServerAddr();\r\n    const url = `${serverAddr}/contract/listContractProcess`;\r\n\r\n    wx.request({\r\n        url: url,\r\n        method: \"POST\",\r\n        header: {\r\n            'Content-Type': 'application/x-www-form-urlencoded'\r\n        },\r\n        data: {\r\n            from: credential.publicKey,\r\n            accessToken: credential.credential\r\n        },\r\n        success: function(res) {\r\n            if (res.data.code !== 0){\r\n                callback(new Error(res.data.message));\r\n                return ;\r\n            }\r\n            callback(undefined, res.data.data);\r\n        },\r\n        fail: function(res) {\r\n            callback(new Error(\"network error\"));\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * Execute a smart contract by given contract ID and action\r\n *\r\n * @param contractInfo  an object containing contract ID and contract action to execute\r\n * @param serverAddr    the server address\r\n * @param credential    an object that is returned by sdk.getCredential()\r\n * @param callback      a function called when the server has responded the sdk.getContractList request.\r\n * @return null.\r\n */\r\nfunction executeContract(contractInfo, serverAddr, credential, callback) {\r\n    if (!serverAddr) serverAddr = getServerAddr();\r\n    var url = `${serverAddr}/contract/executeContract`;\r\n    var data = {\r\n        from: credential.publicKey,\r\n        accessToken: credential.credential,\r\n        contractID: contractInfo.id,\r\n        operation: contractInfo.method,\r\n        arg: contractInfo.arg\r\n    };\r\n\r\n    wx.request({\r\n        url: url,\r\n        method: \"POST\",\r\n        data: data,\r\n        header: {\r\n            'Content-Type': 'application/x-www-form-urlencoded'\r\n        },\r\n        success: function(res) {\r\n            if (res.data.code !== 0){\r\n                callback(new Error(res.data.message));\r\n                return ;\r\n            }\r\n            callback(undefined, res.data.data);\r\n        },\r\n        fail: function(res) {\r\n            callback(new Error(\"network error\"));\r\n        }\r\n    });\r\n};\r\n\r\nfunction promisify(func){\r\n    function wrapped_func(){\r\n        const args = arguments;\r\n        return new Promise((resolve, reject) => {\r\n            func(...args, (err, data) => {\r\n                if (err) reject(err);\r\n                resolve(data);\r\n            });\r\n        });\r\n    };\r\n    return wrapped_func;\r\n};\r\n\r\nconst getCredentialP = promisify(getCredential);\r\nconst storeEvidenceP = promisify(storeEvidence);\r\nconst queryEvidenceP = promisify(queryEvidence);\r\nconst getContractListP = promisify(getContractList);\r\nconst executeContractP = promisify(executeContract);\r\n\r\nmodule.exports = {\r\n    version: \"1.4.3\",\r\n    getServerAddr: getServerAddr,\r\n    getCredential: getCredential,\r\n    storeEvidence: storeEvidence,\r\n    queryEvidence: queryEvidence,\r\n    getContractList: getContractList,\r\n    executeContract: executeContract,\r\n    promises: {\r\n        getServerAddr: getServerAddr,\r\n        getCredential: getCredentialP,\r\n        storeEvidence: storeEvidenceP,\r\n        queryEvidence: queryEvidenceP,\r\n        getContractList: getContractListP,\r\n        executeContract: executeContractP\r\n    }\r\n};\r\n"]}