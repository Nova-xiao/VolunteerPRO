# MiniProgram TaaS SDK


## Prerequisite

* node
* npm
* yarn

If you have not installed `yarn`, please install it by running `npm install -g yarn`. This may require root privilege.

## Setup

Here we use `yarn` to manage the dependencies of the SDK.

Here are some tips about migrating to a yarn environment:
* If you have not initiate the NPM environment in your MiniProgram project, please run `npm init` in the root directory of the project.
* If you have already run `npm init`, but have not installed any dependencies by `npm install` yet, then you can directly install the SDK with `yarn`.
* If you have installed some dependencies by `npm install`, then you can take the following steps to migrate to the yarn environment.
  1. remove the file `package-lock.json` and directory `node_modules` in the root directory of your MiniProgram project.
  2. start a shell with the current working directory being the root directory of the project.
  3. run `yarn install`


Now get the SDK project and place it in somewhere. Suppose that the root directory of the SDK project is `/path/to/miniprogram-taas-sdk`

1. start the shell with the current working directory being the root directory of your MiniProgram project.
2. run `yarn add --flat /path/to/miniprogram-taas-sdk`
3. build npm modules in the WeChat DevTools (Tools -> build npm).

## Usage Example

```javascript
const sdk = require("miniprogram-taas-sdk");

const ic = "<invitation code>";
// generate user credential
sdk.getCredential(ic, undefined, (err, data) => {
    if (err) return ;
    const kp = data;

    // store evidence
    const message = {text: "test_message"};
    sdk.storeEvidence(message, undefined, kp, (err, data) => {
        if (err) return ;
        // get the hash ID
        const hashId = data.hash;

        // query evidence by hash ID
        sdk.queryEvidence(hashId, undefined, kp, (err, data) => {
            if (err) return ;
            // get the response
            const _message = data.data.text;
            console.log(_message); // expect: test_message
        });
    });
});
```

... or use the promises API:

```javascript
const sdkp = require("miniprogram-taas-sdk").promises;

async function main(){
    try {
        const ic = "<invitation code>";

        // generate user credential
        // note: do *NOT* omit the last argument here even if it is `undefined`!
        const kp = await sdkp.getCredential(ic, undefined);

        // store evidence
        const message = {text: "test_message"};
        let data = await sdkp.storeEvidence(message, undefined, kp);
        // get the hash ID
        const hashId = data.hash;

        // query evidence by hash ID
        data = await sdkp.queryEvidence(hashId, undefined, kp);
        // get the response
        const _message = data.data.text;
        console.log(_message) // expect: test_message
    } catch (e){
    };
}

main();
```

## API documentation

You can import the TaaS SDK in your MiniProgram by:
```javascript
const sdk = require("miniprogram-taas-sdk");
const sdkp = sdk.promises;
```

---
### sdk.version

Return the version of TaaS SDK.

The return value is a string which is formatted as `"<major version>.<minor version>.<revision>"` such as `"0.0.1"`.

---
### sdk.getServerAddr()

Return an address of a TaaS backend server. If there are multiple available servers, return a *random* one. Different call to this function may return different server addresses, unless there is only one server avaiable.

The return value is a string, which is formatted as `"<scheme>://<domain>"`, such as `"http://example.com"`.

---
### sdk.getCredential(invitationCode, serverAddress, callback)

Generate a pair of credential keys, which contains a public key, a private key, and an API access token.

The `invitationCode` is the invitation code string.

The `serverAddress` can be a string that returned by `sdk.getServerAddr()`, which specify the server address. It also can be `undefined` (recommended), which means that the server address will be chosen by the SDK itself.

The `callback` should be a function, which will be called when the server has responded the `sdk.storeEvidence` request.
It will be called as `callback(err, obj)`, and the format of the parameter `obj` is:
```typescript
type obj = {
    publicKey: string,
    privateKey: string,
    credential: string
}
```
The public key can identify a user.

This function itself does not return any value.

---
### sdk.storeEvidence(data, serverAddress, credential, callback)

Store evidence of the data in the TaaS backend.

The `data` can be a object, which has the format:
```typescript
type data = {
    path?: string,
    text?: string
}
```
The `data.path` is the path to the file which is going to be stored.
The `data.text` is the message to be stored along with the file.
You should provide at least a file or a message to be stored. When one in `data.path` and `data.text` is provided, the other one can be missing.

The `serverAddress` can be a string that returned by `sdk.getServerAddr()`, which specify the server address. It also can be `undefined` (recommended), which means that the server address will be chosen by the SDK itself.

The `credential` should be an object that is returned by `sdk.getCredential()`.

The `callback` should be a function, which will be called when the server has responded the `sdk.storeEvidence` request.
It will be called as `callback(err, obj)`, and the format of the parameter `obj` is:
```typescript
type obj = {
    hash: string,
    sig: string
}
```
The `hash` is the hash ID of the stored evidence, and the `sig` is the signature of the stored evidence.

This function itself does not return any value.

---
### sdk.queryEvidence(hashId, serverAddress, credential, callback)

Query the data according to a hash ID.

The `hashId` is the hash value to be queried.

The `credential` should be an object that is returned by `sdk.getCredential()`.

The `serverAddress` can be a string that returned by `sdk.getServerAddr()`, which specify the server address. It also can be `undefined` (recommended), which means that the server address will be chosen by the SDK itself.

The `callback` should be a function, which will be called when the server has responded the `sdk.queryEvidence` request.
It will be called as `callback(err, obj)`, and the format of the parameter `obj` is:
```typescript
type obj = {
    data: {
        sig: string,
        data: string,
        text?: string,
        type: string
    },
    from: string,
    sig: string,
    timestamp: number
}
```

The `data.data` is the saved file data (encoded in base64 format).

The `data.type` is the type of the stored data. If a message is stored, the `data.type` will be `"text"`.

The `data.text` is the text stored along with the data.

The `from` is the user's public key, which can identify a user.

The `timestamp` is the timestamp that the user stored the evidence. Technically, it is the number of *milliseconds* that have elapsed since `1970-01-01 00:00:00 (UTC+8)`.

This function itself does not return any value.

---
### sdk.getContractList(serverAddress, credential, callback)

Get the list of all Contracts.

The `credential` should be an object that is returned by `sdk.getCredential()`.

The `serverAddress` can be a string that returned by `sdk.getServerAddr()`, which specify the server address. It also can be `undefined` (recommended), which means that the server address will be chosen by the SDK itself.

The `callback` should be a function, which will be called when the server has responded the `sdk.getContractList` request.
It will be called as `callback(err, obj)`, and the format of the parameter `obj` is:
```typescript
type obj = {
    data: string,
    action: string,
    status: boolean
}
```
Here, the `data` is a _**string**_ that represents a JSON array. The format of the JSON array is
```typescript
type data = {
    id: string
    name: string,
    port: string,
    times: string,
    traffic: string,
    storage: string
    exportedFunctions: {
        annotations: any[],
        functionName: string,
    }[],
    events: any[],
    contractStatus: string
}
```

The `id` is the ID of the contract.
The `functionName` is the name of the function in the contract.

The function itself does not return any value.

---
### sdk.executeContract(contractInfo, serverAddress, credential, callback)

Execute a contract and get the results.

The `contractInfo` should be an object that contains the information of the contract which is going to be executed. The format of `contractInfo` is:
```typescript
type contractInfo = {
    id: string,
    method: string,
    arg: string
}
```
The `id` is the ID of the contract to be executed.
The `functionName` is the name of the function in the contract.
The `arg` is the argument of the function.

The `credential` should be an object that is returned by `sdk.getCredential()`.

The `serverAddress` can be a string that returned by `sdk.getServerAddr()`, which specify the server address. It also can be `undefined` (recommended), which means that the server address will be chosen by the SDK itself.

The `callback` should be a function, which will be called when the server has responded the `sdk.getContractList` request.
It will be called as `callback(err, obj)`, and the format of the parameter `obj` is:
```typescript
type obj = {
    data: string,
    action: string,
    executeTime: string
}
```
The `data` is a _**string**_ that represents a JSON object. The format of the object is:
```typescript
type data = {
    status: string,
    result: string
}
```
The `result` is the result of the execution.

The function itself does not return any value.

---
### sdk.promises
The `sdk.promises` is another set of APIs that use `Promise` as its interface instead of the traditional callback.

All functions in `sdk` have an equivalent function in `sdk.promises`, no matter whether the function itself needs a callback (such as `sdk.storeEvidence`) or not (such as `sdk.getServerAddr`).
Note: `sdk.version` is not included in `sdk.promises` because `sdk.version` is a string but not a function.

The names and functionaliyies of the functions in `sdk.promises` is identical to the functions in `sdk`.

An usage example is shown above in the section Usage Example.

The functions in `sdk` and the functions in `sdk.promises` do not interfere with each other.
That is to say, you can mix the usage of functions in `sdk` and `sdk.promises` in your project. It will not cause any trouble.
